#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""Tests for demo plotters module organization."""

import matplotlib

matplotlib.use("Agg")

import numpy as np

import figrecipe as fr
from figrecipe._dev.demo_plotters import (
    CATEGORIES,
    CATEGORY_DISPLAY_NAMES,
    REGISTRY,
    REPRESENTATIVES,
    get_plotter,
    get_representative_plots,
    list_plots,
    list_plots_by_category,
)


class TestRegistry:
    """Tests for the demo plotters registry."""

    def test_registry_not_empty(self):
        """Registry should contain plot functions."""
        assert len(REGISTRY) > 0

    def test_registry_has_expected_count(self):
        """Registry should have 46 plot types."""
        assert len(REGISTRY) == 46

    def test_registry_functions_callable(self):
        """All registry entries should be callable."""
        for name, func in REGISTRY.items():
            assert callable(func), f"{name} is not callable"

    def test_registry_contains_common_plots(self):
        """Registry should contain common plot types."""
        common_plots = ["plot", "scatter", "bar", "hist", "imshow", "pie"]
        for plot_name in common_plots:
            assert plot_name in REGISTRY, f"{plot_name} not in registry"


class TestCategories:
    """Tests for category organization."""

    def test_categories_not_empty(self):
        """Categories should not be empty."""
        assert len(CATEGORIES) > 0

    def test_expected_category_count(self):
        """Should have 9 categories."""
        assert len(CATEGORIES) == 9

    def test_category_names_are_directory_style(self):
        """Category names should use underscore style (directory names)."""
        expected_categories = [
            "line_curve",
            "scatter_points",
            "bar_categorical",
            "distribution",
            "image_matrix",
            "contour_surface",
            "spectral_signal",
            "vector_flow",
            "special",
        ]
        for cat in expected_categories:
            assert cat in CATEGORIES, f"{cat} not in CATEGORIES"

    def test_all_category_plots_in_registry(self):
        """All plots in categories should exist in registry."""
        for cat_name, plot_list in CATEGORIES.items():
            for plot_name in plot_list:
                assert plot_name in REGISTRY, (
                    f"{plot_name} from {cat_name} not in registry"
                )

    def test_category_display_names_exist(self):
        """Each category should have a display name."""
        for cat_name in CATEGORIES.keys():
            assert cat_name in CATEGORY_DISPLAY_NAMES, (
                f"{cat_name} missing display name"
            )

    def test_category_display_names_readable(self):
        """Display names should be human-readable (not underscore style)."""
        for cat_name, display_name in CATEGORY_DISPLAY_NAMES.items():
            # Should not contain underscores (unlike directory names)
            assert "_" not in display_name, (
                f"{display_name} should not contain underscores"
            )
            # Display name should be different from directory name
            assert display_name != cat_name, (
                f"{display_name} should differ from directory name {cat_name}"
            )


class TestRepresentatives:
    """Tests for representative plots."""

    def test_representatives_not_empty(self):
        """Representatives should not be empty."""
        assert len(REPRESENTATIVES) > 0

    def test_one_representative_per_category(self):
        """Each category should have exactly one representative."""
        for cat_name in CATEGORIES.keys():
            assert cat_name in REPRESENTATIVES, f"{cat_name} missing representative"

    def test_representatives_in_registry(self):
        """All representatives should exist in registry."""
        for cat_name, plot_name in REPRESENTATIVES.items():
            assert plot_name in REGISTRY, (
                f"Representative {plot_name} for {cat_name} not in registry"
            )

    def test_representatives_in_their_category(self):
        """Representatives should belong to their category."""
        for cat_name, plot_name in REPRESENTATIVES.items():
            if cat_name in CATEGORIES:
                assert plot_name in CATEGORIES[cat_name], (
                    f"{plot_name} not in {cat_name} category"
                )


class TestHelperFunctions:
    """Tests for helper functions."""

    def test_list_plots_returns_all(self):
        """list_plots should return all plot names."""
        plots = list_plots()
        assert len(plots) == len(REGISTRY)
        assert set(plots) == set(REGISTRY.keys())

    def test_list_plots_by_category_returns_dict(self):
        """list_plots_by_category should return category dict."""
        result = list_plots_by_category()
        assert isinstance(result, dict)
        assert len(result) == len(CATEGORIES)

    def test_get_representative_plots(self):
        """get_representative_plots should return representatives."""
        reps = get_representative_plots()
        assert isinstance(reps, list)
        assert len(reps) == len(REPRESENTATIVES)

    def test_get_plotter_returns_function(self):
        """get_plotter should return callable for valid plot name."""
        func = get_plotter("scatter")
        assert callable(func)

    def test_get_plotter_invalid_returns_none(self):
        """get_plotter should return None for invalid plot name."""
        func = get_plotter("nonexistent_plot_type")
        assert func is None


class TestPlotterExecution:
    """Tests that plotters can actually execute."""

    def test_scatter_plotter_executes(self):
        """Scatter plotter should execute without error."""
        rng = np.random.default_rng(42)
        func = REGISTRY["scatter"]
        fig, ax = func(fr, rng)
        assert fig is not None
        assert ax is not None

    def test_plot_plotter_executes(self):
        """Plot (line) plotter should execute without error."""
        rng = np.random.default_rng(42)
        func = REGISTRY["plot"]
        fig, ax = func(fr, rng)
        assert fig is not None
        assert ax is not None

    def test_bar_plotter_executes(self):
        """Bar plotter should execute without error."""
        rng = np.random.default_rng(42)
        func = REGISTRY["bar"]
        fig, ax = func(fr, rng)
        assert fig is not None
        assert ax is not None

    def test_hist_plotter_executes(self):
        """Hist plotter should execute without error."""
        rng = np.random.default_rng(42)
        func = REGISTRY["hist"]
        fig, ax = func(fr, rng)
        assert fig is not None
        assert ax is not None

    def test_all_representatives_execute(self):
        """All representative plotters should execute without error."""
        rng = np.random.default_rng(42)
        for cat_name, plot_name in REPRESENTATIVES.items():
            func = REGISTRY[plot_name]
            fig, ax = func(fr, rng)
            assert fig is not None, f"{plot_name} returned None fig"
            assert ax is not None, f"{plot_name} returned None ax"


import tempfile
from pathlib import Path

import pytest


class TestFigureSaving:
    """Tests for figure saving functionality."""

    def test_save_png_only(self):
        """Save figure as PNG without recipe."""
        rng = np.random.default_rng(42)
        func = REGISTRY["scatter"]
        fig, ax = func(fr, rng)

        with tempfile.TemporaryDirectory() as tmpdir:
            png_path = Path(tmpdir) / "test.png"
            result = fig.savefig(png_path, save_recipe=False, verbose=False)

            assert png_path.exists(), "PNG file should exist"
            assert result == png_path
            # No YAML should be created
            yaml_path = png_path.with_suffix(".yaml")
            assert not yaml_path.exists(), (
                "YAML should not exist when save_recipe=False"
            )

    def test_save_with_recipe(self):
        """Save figure with recipe (default behavior)."""
        rng = np.random.default_rng(42)
        func = REGISTRY["scatter"]
        fig, ax = func(fr, rng)

        with tempfile.TemporaryDirectory() as tmpdir:
            png_path = Path(tmpdir) / "test.png"
            img_path, recipe_path = fig.savefig(png_path, verbose=False)

            assert png_path.exists(), "PNG file should exist"
            assert recipe_path.exists(), "YAML recipe should exist"
            assert recipe_path.suffix == ".yaml"

    def test_recipe_is_valid_yaml(self):
        """Recipe file should be valid YAML."""
        import yaml

        rng = np.random.default_rng(42)
        func = REGISTRY["bar"]
        fig, ax = func(fr, rng)

        with tempfile.TemporaryDirectory() as tmpdir:
            png_path = Path(tmpdir) / "test.png"
            _, recipe_path = fig.savefig(png_path, verbose=False)

            with open(recipe_path) as f:
                data = yaml.safe_load(f)

            assert "figrecipe" in data, "Recipe should have figrecipe version"
            assert "axes" in data, "Recipe should have axes"
            assert "figure" in data, "Recipe should have figure settings"

    def test_reproduce_from_saved_figure(self):
        """Saved figure should be reproducible."""
        rng = np.random.default_rng(42)
        func = REGISTRY["hist"]
        fig, ax = func(fr, rng)

        with tempfile.TemporaryDirectory() as tmpdir:
            png_path = Path(tmpdir) / "test.png"
            fig.savefig(png_path, verbose=False)

            # Reproduce
            fig2, ax2 = fr.reproduce(png_path)

            assert fig2 is not None, "Reproduced figure should not be None"
            assert ax2 is not None, "Reproduced axes should not be None"

    @pytest.mark.parametrize("plot_name", list(REPRESENTATIVES.values()))
    def test_save_all_representatives(self, plot_name):
        """All representative plots should save without error."""
        rng = np.random.default_rng(42)
        func = REGISTRY[plot_name]
        fig, ax = func(fr, rng)

        with tempfile.TemporaryDirectory() as tmpdir:
            png_path = Path(tmpdir) / f"{plot_name}.png"
            img_path, recipe_path = fig.savefig(png_path, verbose=False)

            assert png_path.exists(), f"{plot_name}: PNG should exist"
            assert recipe_path.exists(), f"{plot_name}: recipe should exist"

    @pytest.mark.parametrize("plot_name", list(REPRESENTATIVES.values()))
    def test_reproduce_all_representatives(self, plot_name):
        """All representative plots should reproduce without error."""
        rng = np.random.default_rng(42)
        func = REGISTRY[plot_name]
        fig, ax = func(fr, rng)

        with tempfile.TemporaryDirectory() as tmpdir:
            png_path = Path(tmpdir) / f"{plot_name}.png"
            fig.savefig(png_path, verbose=False)

            # Reproduce
            fig2, ax2 = fr.reproduce(png_path)

            assert fig2 is not None, f"{plot_name}: reproduced fig should not be None"
            assert ax2 is not None, f"{plot_name}: reproduced ax should not be None"
